/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package lastedited;

import java.awt.event.ActionEvent;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.swing.AbstractAction;
import javax.swing.DefaultListModel;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.ListSelectionModel;
import javax.swing.event.ChangeEvent;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.cookies.OpenCookie;
import org.openide.filesystems.FileChangeAdapter;
import org.openide.filesystems.FileChangeListener;
import org.openide.filesystems.FileEvent;
import org.openide.filesystems.FileObject;
import org.openide.filesystems.FileRenameEvent;
import org.openide.loaders.DataObject;
import org.openide.util.NbBundle.Messages;
import org.openide.windows.TopComponent;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(
        dtd = "-//lastedited//lastedited//EN",
        autostore = false
)
@TopComponent.Description(
        preferredID = "LasteditedTopComponent",
        //iconBase="SET/PATH/TO/ICON/HERE", 
        persistenceType = TopComponent.PERSISTENCE_ALWAYS
)
@TopComponent.Registration(mode = "navigator", openAtStartup = true)
@ActionID(category = "Window", id = "lastedited.LasteditedTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
        displayName = "#CTL_LastEditedAction",
        preferredID = "LasteditedTopComponent"
)
@Messages(
        {
            "CTL_LastEditedAction=Last Edited",
            "CTL_LasteditedTopComponent=Last Edited",
            "HINT_LasteditedTopComponent=This is a Last Edited window"
        })
public final class LastEditedTopComponent extends TopComponent
{

    private final List<FileObject> changedFOs = new ArrayList<>();
    private final Set<FileObject> fosWithListeners = new HashSet<>();
    private final Map<FileObject, Long> lastAccess = new HashMap<>();
    FileChangeListener fcl;

    public LastEditedTopComponent()
    {
        initComponents();
        setName( Bundle.CTL_LasteditedTopComponent() );
        setToolTipText( Bundle.HINT_LasteditedTopComponent() );

        start();

    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        jScrollPane1 = new javax.swing.JScrollPane();
        list = new javax.swing.JList();
        txtSearch = new javax.swing.JTextField();

        list.setModel(new javax.swing.AbstractListModel()
        {
            String[] strings = { "Item 1", "Item 2", "Item 3", "Item 4", "Item 5" };
            public int getSize() { return strings.length; }
            public Object getElementAt(int i) { return strings[i]; }
        });
        jScrollPane1.setViewportView(list);

        txtSearch.setText(org.openide.util.NbBundle.getMessage(LastEditedTopComponent.class, "LastEditedTopComponent.txtSearch.text")); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addComponent(txtSearch, javax.swing.GroupLayout.DEFAULT_SIZE, 424, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 275, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(txtSearch, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(9, 9, 9))
        );
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JList list;
    private javax.swing.JTextField txtSearch;
    // End of variables declaration//GEN-END:variables

    @Override
    public void componentOpened()
    {
        // TODO add custom code on component opening
    }

    @Override
    public void componentClosed()
    {
        // TODO add custom code on component closing
    }

    private void start()
    {
        txtSearch.setText( "" );
        setListModel();
        list.setSelectionMode( ListSelectionModel.SINGLE_SELECTION );
        fcl = new FileChangeAdapter()
        {
            @Override
            public void fileChanged( FileEvent fe )
            {
                synchronized ( LastEditedTopComponent.this )
                {
                    FileObject fo = (FileObject) fe.getSource();

                    lastAccess.put( fo, System.currentTimeMillis() );
                    if ( !changedFOs.contains( fo ) )
                    {
                        changedFOs.add( fo );
                    }

                    List<FileObject> toBeRemoved = new ArrayList<>();
                    List<String> names = new ArrayList<>();
                    for ( FileObject f : changedFOs )
                    {
                        if ( !names.contains( f.getNameExt() ) )
                        {
                            names.add( f.getNameExt() );
                        }
                        else
                        {
                            toBeRemoved.add( f );
                            lastAccess.remove( f );
                        }
                    }

                    changedFOs.removeAll( toBeRemoved );
                    setListModel();
                }

            }

            @Override
            public void fileDeleted( FileEvent fe )
            {
                FileObject fo = (FileObject) fe.getSource();
                changedFOs.remove( fo );
                lastAccess.remove( fo );
                setListModel();
            }

            @Override
            public void fileRenamed( FileRenameEvent fe )
            {
                FileObject fo = (FileObject) fe.getSource();
                changedFOs.remove( fo );
                lastAccess.remove( fo );
                setListModel();
            }

        };

        DataObject.getRegistry().addChangeListener( (ChangeEvent e) ->
        {
            getChangedFileObjects().stream().filter( (fo) -> ( !fosWithListeners.contains( fo ) ) ).forEach( (fo) ->
            {
                fosWithListeners.add( fo );
                fo.addFileChangeListener( fcl );
            } );
        } );

        addFocusListener( new FocusAdapter()
        {
            @Override
            public void focusGained( FocusEvent e )
            {
                txtSearch.requestFocus();
            }

        } );

        txtSearch.addKeyListener( new KeyAdapter()
        {
            @Override
            public void keyPressed( KeyEvent e )
            {
                if ( e.getKeyCode() == 38 || e.getKeyCode() == 40 )
                {
                    list.requestFocus();
                }
            }

            @Override
            public void keyReleased( KeyEvent e )
            {
                if ( e.getKeyCode() == 27 )
                {
                    // ESC
                    txtSearch.setText( "" );
                    setListModel();
                }
                else if ( e.getKeyCode() == 10 )
                {
                    if ( list.getSelectedIndex() == -1 && list.getModel().getSize() == 1 )
                    {
                        list.setSelectedIndex( 0 );
                    }
                    // Enter
                    openFile();
                }
                else
                {
                    setListModel();
                }
            }

            @Override
            public void keyTyped( KeyEvent e )
            {
                // no use
            }
        } );

        list.addMouseListener( new MouseAdapter()
        {

            @Override
            public void mouseClicked( MouseEvent e )
            {
                if ( e.getButton() != MouseEvent.BUTTON1 )
                {
                    JPopupMenu popup = new JPopupMenu();
                    popup.add( new JMenuItem( new AbstractAction( "kick" )
                    {

                        @Override
                        public void actionPerformed( ActionEvent e )
                        {
                            kickFile();
                        }
                    } ) );
                    popup.show( LastEditedTopComponent.this, e.getX(), e.getY() );
                }
                else
                {
                    openFile();
                }
            }

        } );

        list.addKeyListener( new KeyAdapter()
        {
            @Override
            public void keyPressed( KeyEvent e )
            {
                if ( e.getKeyCode() == 10 )
                {
                    openFile();
                }
            }

        } );

    }

    private FileObject getSelectedFileObject()
    {
        Object selObj = list.getSelectedValue();
        if ( selObj != null )
        {
            String val = (String) selObj;

            try
            {
                FileObject f = changedFOs.stream().filter( fo -> fo.getNameExt().trim().equals( val.trim() ) ).findFirst().get();
                return f;
            }
            catch ( Exception ex )
            {
                System.err.println( "Last Edited: " + ex.getMessage() );
            }

        }
        return null;
    }

    private void openFile()
    {
        try
        {
            FileObject f = getSelectedFileObject();
            f.getLookup().lookup( OpenCookie.class ).open();
        }
        catch ( Exception ex )
        {
            System.err.println( "Last Edited: " + ex.getMessage() );
        }

    }

    private void kickFile()
    {
        FileObject selectedFileObject = getSelectedFileObject();

        changedFOs.remove( selectedFileObject );
        setListModel();
    }

    private void setListModel()
    {
        Collections.sort( changedFOs, (FileObject o1, FileObject o2) -> lastAccess.get( o2 ).compareTo( lastAccess.get( o1 ) ) );

        List<FileObject> toShow = new ArrayList<>();

        String searchString = txtSearch.getText();

        if ( searchString.isEmpty() )
        {
            toShow.addAll( changedFOs );
        }
        else
        {
            for ( FileObject fo : changedFOs )
            {

                if ( fo.getNameExt().toLowerCase().contains( searchString.trim().toLowerCase() ) )
                {
                    toShow.add( fo );
                }

            }
        }

        list.setModel( new DefaultListModel()
        {

            @Override
            public Object getElementAt( int index )
            {
                return toShow.get( index ).getNameExt();
            }

            @Override
            public int getSize()
            {
                return toShow.size();
            }

        } );
    }

    private Set<FileObject> getChangedFileObjects()
    {
        Set<FileObject> res = new HashSet<>();
        DataObject[] objects = DataObject.getRegistry().getModified();
        for ( DataObject object : objects )
        {
            Set<FileObject> fss = object.files();
            res.addAll( fss );
        }

        return res;
    }

    void writeProperties( java.util.Properties p )
    {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty( "version", "1.0" );
        // TODO store your settings
    }

    void readProperties( java.util.Properties p )
    {
        String version = p.getProperty( "version" );
        // TODO read your settings according to their version
    }
}
